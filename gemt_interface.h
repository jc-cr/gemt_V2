#include "HardwareSerial.h"
#ifndef gemt_interface_h
#define gemt_interface_h

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Fonts/Org_01.h>
#include <Adafruit_SSD1306.h>
#include <EncoderButton.h>
#include "Arduino.h"

/*========================================================================
 TODO:
  - Add a method to pass length of user menus from main to this header
  - Setup encoder click selections
  - Integrate hardware tests
  -  ...
========================================================================*/

//========================================================================
// Global Definitions
//========================================================================

#define displayRowLimit 8;
#define displayColLimit 21;

unsigned short int ebState = 0; // Current state (Position) of the encoder 
unsigned short int currentScrollLimit = 0; // Updated within displayMenu function
bool clicked = false; // Updated on encoder "click" case, must reset after use 

enum encoderSWPins 
{
  pinA = 19 , // CLK
  pinB = 2, // DT
  pinSW = 8 // SW
};

enum oledDisplayPins
{
  screenWidth = 128,
  screenHeight = 64,
  screenAddress = 0x3C, // i2c Address
  screenReset = -1      // -1 since sharing Arduino reset pin
};

//========================================================================
// Initializers
//========================================================================

// Display init
Adafruit_SSD1306 display(screenWidth, screenHeight, &Wire, screenReset);

// EncoderSW init
EncoderButton eb1(pinA, pinB, pinSW);

// Logo Bitmap Init
 const uint8_t  logo_bmp [] PROGMEM = 
{ 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0x86, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x80, 0x00, 0x3e, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x77, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x38, 0x01, 0xc3, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x0e, 0x07, 0x81, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x87, 0x03, 0x8e, 0x00, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0xf8, 0x00, 0x70, 0x00, 0x00, 
  0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x30, 0x00, 0x38, 0x00, 0x00, 
  0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 
  0x00, 0x00, 0xe0, 0x00, 0x3f, 0xfc, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
  0x00, 0x01, 0xc0, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 
  0x00, 0x03, 0x80, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 
  0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 
  0x00, 0x0e, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 
  0x00, 0x1c, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 
  0x00, 0x38, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
  0x00, 0x78, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0x87, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x01, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xf8, 0x7f, 0xfc, 0x1f, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xc0, 
  0x00, 0x7f, 0xff, 0xe0, 0x7f, 0xff, 0xfc, 0x7f, 0xfc, 0x3f, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0x00, 
  0x00, 0x1f, 0xff, 0xf0, 0x3f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xf0, 0x3f, 0xff, 0xfc, 0x00, 
  0x00, 0x07, 0xff, 0xfc, 0x1f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xe0, 0x7f, 0xff, 0xf0, 0x00, 
  0x00, 0x03, 0xff, 0xfe, 0x0f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xc0, 0xff, 0xff, 0xc0, 0x00, 
  0x00, 0x00, 0xff, 0xff, 0x07, 0xff, 0xfe, 0x3f, 0xfc, 0x7f, 0xff, 0x81, 0xff, 0xff, 0x80, 0x00, 
  0x00, 0x00, 0x3f, 0xff, 0x83, 0xff, 0xfe, 0x3f, 0xf8, 0x7f, 0xff, 0x03, 0xff, 0xfe, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0xff, 0xc1, 0xff, 0xfe, 0x1f, 0xf8, 0x7f, 0xfe, 0x07, 0xff, 0xf8, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0xff, 0xe0, 0xff, 0xfe, 0x1f, 0xf8, 0x7f, 0xfe, 0x0f, 0xff, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0xff, 0xf0, 0x7f, 0xff, 0x1f, 0xf8, 0xff, 0xfc, 0x1f, 0xff, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x7f, 0xf8, 0x3f, 0xff, 0x1f, 0xf8, 0xff, 0xf8, 0x3f, 0xff, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x3f, 0xfc, 0x1f, 0xff, 0x1f, 0xf0, 0xff, 0xf0, 0x7f, 0xfc, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0f, 0xfe, 0x0f, 0xff, 0x8f, 0xf0, 0xff, 0xe0, 0xff, 0xf0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x03, 0xff, 0x07, 0xff, 0x8f, 0xf1, 0xff, 0xc1, 0xff, 0xe0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xff, 0x83, 0xff, 0x8f, 0xf1, 0xff, 0x83, 0xff, 0x80, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x7f, 0xe1, 0xff, 0x8f, 0xf1, 0xff, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x7f, 0xcf, 0xe3, 0xfe, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x3f, 0xc7, 0xe3, 0xfc, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x1f, 0xc7, 0xe3, 0xf8, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0xe7, 0xe3, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x07, 0xe7, 0xe7, 0xe1, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x83, 0xe7, 0xc7, 0xc3, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc1, 0xe3, 0xc7, 0x87, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0xf3, 0xc7, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x73, 0xce, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x33, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x13, 0x8c, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0b, 0x88, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

//========================================================================
// Encoder Handlers
//========================================================================
  
// On click, the global selection variable gets updated with
// value of where it was selcted
void onEb1Clicked(EncoderButton& eb)
{
  // Set selection value to current state
  clicked = true;
  
  // DEBUG - Delete in actual proram as Serial printing slows down interrupts
  //Serial.println(selection);
}

// A function to handle the 'encoder' event
void onEb1Encoder(EncoderButton& eb) 
{
  // Filter latge spikes from noise
  if(eb.increment() > 4)
  {
    eb.resetPosition(eb.position()); // Reset back to startin pos
  }

  // Reset if encoder goes past active Menu limit
  if (abs(eb.position()) >= currentScrollLimit)
  {
    eb.resetPosition(0);
  }

  ebState = abs(eb.position());
}
 
//========================================================================
// Helper functions
//========================================================================

// Function to print horizontal line of a char
void printHline(char lineChar)
{
  for (int i = 0; i < 72; ++i)
  {
    Serial.print(lineChar);
  }

  Serial.println();
}

void displayPrep(void)
{
    display.clearDisplay();
    display.setCursor(0, 0);
    display.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
}
//========================================================================
// Menu Functions
//========================================================================

/*
  // Setup linked list to create function paramter lists 
  // https://www.learn-c.org/en/Linked_lists
  // https://codereview.stackexchange.com/questions/237794/generic-linked-list-implemented-in-pure-c
  typedef struct ArgList {
      void* passedArg;
      struct ArgList *next;
  } ArgList;

  void push(ArgList * head, void* nextArg) 
  {
      ArgList * current = head;
      while (current->next != NULL) 
      {
          current = current->next;
      }

      
      current->next = (ArgList *) malloc(sizeof(ArgList));
      current->next->passedArg = nextArg;
      current->next->next = NULL;
  }
*/
// Menu screen template
typedef struct Menu
{
  unsigned int choice;
  const char* menuTextPtr;
  void (*selectionAction)(...); // Function pointer to Menu selection action
  //ArgList *head;

  //void setSelectionParams(...);
  //void runSelectionAction(...);
  // Method styling in C https://www.cs.uaf.edu/courses/cs301/2014-fall/notes/methods/index.html
  // Ellipses ref https://www.lemoda.net/c/function-pointer-ellipsis/
} Menu;

/*
void setMenuActionParams(Menu Menu[], short unsigned int numberOfArgs, ...)
{
  va_list inputArg;
  va_start(inputArg, numberOfArgs);
  
  Menu.head = (ArgList *) malloc(sizeof(ArgList));
  
  // Memory allocaiton failed
  if (Menu.head == NULL) 
  {
    Serial.println("malloc fail");
    return;
  }

  Menu.head->passedArg = inputArg;  

  // We start at 1 since we've already assigned the head
  for (int i = 1; i < numberArg; i++)
  {
    push(Menu.head, inputArg[i]);
  }  

  va_end(args);
}

*/


/*
void setSelectionParams(Menu menu, ...)
{
  va_list args;
  va_start(args, menu);
  menu.setSelectionParams = std::bind(menu.setSelectionAction, args);
  va_end(args);
}

void runSelectionAction(Menu Menu, ...)
{
  va_list argp;
	va_start(argp, Menu);
  passParameters(Menu.setSelectionAction, argp);
  va_end(argp);
}
*/

//========================================================================
// Screen Display functions
//========================================================================

// Bootup fucnction for display
void startInterface(void) 
{ 
  if(!display.begin(SSD1306_SWITCHCAPVCC, screenAddress)) {
    display.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  //Link the event(s) to your function
  eb1.setClickHandler(onEb1Clicked);
  eb1.setEncoderHandler(onEb1Encoder);

  // Display logo for 2 sec
  display.clearDisplay();
  display.drawBitmap(0, 0, logo_bmp, screenWidth, screenHeight - 5, WHITE); // -5, bc getting some weird stuff at bottom of screen
  display.display();
  delay(2000);
  
  display.clearDisplay();  
  display.display();
}

// 
void displayMenu(Menu CurrentMenu[], size_t menuLength)
{
  // Execute function if clicked...
  // So either go to a submenu or run a module test
  // After module test the display function should still be in same state (pretty cool)

  if (clicked)
  {
    clicked = 0; // Reset before proceeding to function
    CurrentMenu[ebState].selectionAction();
    //CurrentMenu[ebState].setSelectionAction(CurrentMenu[ebState].params);
  }

  //Display the previous Menu state
  else
  {
    char buffer[50]; // init buffer of 50 bytes to hold expected string size
    currentScrollLimit = menuLength;

    // Setup
    eb1.update();
    display.clearDisplay();
    display.setCursor(0, 0);
    display.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
    
    // Printing header line
    display.println("Select module test:");
    // Display all current Menu options
    for (size_t i = 0; i <= (menuLength - 1); ++i)
    {
      // Highlight line if user is hovering over it
      if (ebState == i)
      {
        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
      }
      else 
      {
        display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
      }
      
      // Print out in int and Text format
      sprintf(buffer, "%d. %s", CurrentMenu[i].choice, CurrentMenu[i].menuTextPtr);
      display.println(buffer);
    }
    
    display.display();
  }
}

// Changes Menu pointer to point to selected Menu screen
void menuUpdate(Menu NewMenu[], size_t newMenuLength, Menu* OldMenuPtr, size_t* oldMenuLengthPtr)
{
  OldMenuPtr = NewMenu;
  oldMenuLengthPtr = newMenuLength;
}

//========================================================================
// Debugging
//========================================================================

void dummyInfo(void)
{
  currentScrollLimit = 2;

  while (clicked == 0)
  {
    displayPrep();

    display.println("Test Information:");
    display.println();
    display.println("This is a demo of an info screen for a test.");
    display.println();
    

    if (ebState = 0)
    {
      display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
    }
    display.print("OK"); 

    display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
    display.print("  |  "); 
    display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 

    if (ebState = 2)
    {
      display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
    }
    display.print("Back");
    display.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
    
    display.display();

    delay(3);
  }

  // When cliked we exit and do nothing
  clicked = 0;
}

// Demo of a test, no way to transition out 
void dummyTest(void)
{
  displayPrep();

  dummyInfo();

  while(clicked == 0)
  {
    displayPrep();
    display.println("This is a demo of a Test screen");
    display.display();

    delay(3);
  }

  clicked = 0;
}

// Demo of a submenu, no way to transition to real menuss... just for demo
void dummyMenu(void)
{
  // Make a Dumb Menu
  static Menu DumbMenu[] =
  {
    {1, "Test 1", dummyTest},
    {2,  "Test 2", dummyTest},
    {3, "Dumb Menu", dummyMenu}, // Action - Update Menu, Main
  };
  size_t dumbMenuLength = sizeof(DumbMenu) / sizeof(DumbMenu[0]);

  while(true)
  {
    displayMenu(DumbMenu, dumbMenuLength);

    delay(3);
  }
}


/*
//========================================================================
// OG Code for Ref
//========================================================================

// Function to get user menu selection from serial monitor input
// menuName - Name for the desired menu (Main, Sub, Servo, etc.)
// menuOptions - List of options in your testing suite
// menuArraySize - number of elements in menuOptions
unsigned short int menuSelection(String menuName, const char* menuOptions[], size_t menuArraySize)
{
  unsigned short int selection;
  char buffer[50]; // init buffer of 50 bytes to hold expected string size

  printHline('*');
  
  display.println(menuName);

  // Assign item number to menuOption. Starts at 1.
  for (size_t i = 1; i <= menuArraySize; ++i)
  {    
    sprintf(buffer, "%d. %s", i, menuOptions[i-1]);
    display.println(buffer);
  }

  printHline('*');

  display.println("Type item number of desired test: \n"); 
  printHline('*');

  selection = getSerialInput_int();
  
  // Auto catch any invalid menu selection parameters
  // From getSerialInput_int() we assume 0 is not an option
  while (selection > menuArraySize || selection <= 0)
  {
    selection = getSerialInput_int();
  }

  display.display();
  delay(2000);  
  // Return user selection input
  return selection; 
}

// Displays the instructions to a test (pins to connect to, etc.)
// bool return determines if test will proceed or go back to previous screen
bool infoScreen (String infoMsg)
{
  bool proceed = 0;
  unsigned short int selection;
  
  printHline('-');
  display.println("Test Info Screen: ");
  display.println(infoMsg);
  printHline('-');
  
  display.println("1. OK");
  display.println("2. BACK");
  printHline('-');
  display.println("Type item number of desired action:");
  printHline('-');

  selection = getSerialInput_int();
  
  // Loop until we get correct input
  while (selection != 1 && selection != 2)
  {
    display.print(selection); display.print(" is an invalid input! \n");
    display.println("Please try enter 1 or 2");
    selection = getSerialInput_int();
  }

  // Return param to continue to next screen
  if (selection == 1)
  {
    proceed = true;
  }
  // Return param to return to previous screen
  else if (selection == 2)
  {
    proceed = false;
  }

  return proceed;
}

*/


/*
// OG GEMT Main menu
// Highlights option when encoder is postioned on item
// Encouder push selects that item
unsigned int GEMT_mainMenu (void)
{ 
  size_t eb_state = abs(eb1.position());
  selection = noSelection;
  eb1.update();  

  display.clearDisplay();
  display.setTextSize(1); 
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 

  // Print header
  display.println("Select module test:");

  // Prints all lines from menu, may need to add second page if too much text
  for (size_t i = 0; i < mainMenu_length; ++i) 
  {
    // Highlight line if user is hovering over it
    // Line 0 not clickable 
    if (eb_state == (i+1))
    {
      display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
    }
    else 
    {
      display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
    }

    display.println(main_menu[i].menuTextPtr);  
  }

  // Return to top of list if encoder pos goes past last choice
  // In future could update to transition to a second page
  if (eb_state > (mainMenu_length - 1))
  {
    eb1.resetPosition(1); 
  }
 
  display.display();

  return selection; // return default if nothing selection, otherwise returns value of selction
}
*/

#endif 