#ifndef gemt_interface_h
#define gemt_interface_h

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Fonts/Org_01.h>
#include <Adafruit_SSD1306.h>
#include <EncoderButton.h>
#include "Arduino.h"

//========================================================================
// Global Definitions
//========================================================================

#define displayRowLimit 8;
#define displayColLimit 21;

unsigned short int ebState = 0;
unsigned short int currentScrollLimit = 0;

enum encoderSWPins 
{
  pinA = 19 , // CLK
  pinB = 2, // DT
  pinSW = 8 // SW
};

enum oledDisplayPins
{
  screenWidth = 128,
  screenHeight = 64,
  screenAddress = 0x3C, // i2c Address
  screenReset = -1      // -1 since sharing Arduino reset pin
};

//========================================================================
// Menu Functions
//========================================================================

// Code base on: https://stackoverflow.com/questions/51328435/best-way-to-create-a-console-menu-c
typedef void (*Menu_Processing_Function_Pointer)(void);
// Menu screen template
typedef struct Menu
  {
    unsigned int choice;
    const char* menuTextPtr;
    Menu_Processing_Function_Pointer p_processing_function;
  } Menu;

// TODO: Add a method to pass length of user menus from main to this header

//========================================================================
// Initializers
//========================================================================

// Display init
Adafruit_SSD1306 display(screenWidth, screenHeight, &Wire, screenReset);

// EncoderSW init
EncoderButton eb1(pinA, pinB, pinSW);

// Logo Bitmap Init
 const uint8_t  logo_bmp [] PROGMEM = 
{ 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0x86, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x80, 0x00, 0x3e, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x77, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x38, 0x01, 0xc3, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x0e, 0x07, 0x81, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x87, 0x03, 0x8e, 0x00, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0xf8, 0x00, 0x70, 0x00, 0x00, 
  0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x30, 0x00, 0x38, 0x00, 0x00, 
  0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 
  0x00, 0x00, 0xe0, 0x00, 0x3f, 0xfc, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
  0x00, 0x01, 0xc0, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 
  0x00, 0x03, 0x80, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 
  0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 
  0x00, 0x0e, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 
  0x00, 0x1c, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 
  0x00, 0x38, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
  0x00, 0x78, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0x87, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x01, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xf8, 0x7f, 0xfc, 0x1f, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xc0, 
  0x00, 0x7f, 0xff, 0xe0, 0x7f, 0xff, 0xfc, 0x7f, 0xfc, 0x3f, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0x00, 
  0x00, 0x1f, 0xff, 0xf0, 0x3f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xf0, 0x3f, 0xff, 0xfc, 0x00, 
  0x00, 0x07, 0xff, 0xfc, 0x1f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xe0, 0x7f, 0xff, 0xf0, 0x00, 
  0x00, 0x03, 0xff, 0xfe, 0x0f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xc0, 0xff, 0xff, 0xc0, 0x00, 
  0x00, 0x00, 0xff, 0xff, 0x07, 0xff, 0xfe, 0x3f, 0xfc, 0x7f, 0xff, 0x81, 0xff, 0xff, 0x80, 0x00, 
  0x00, 0x00, 0x3f, 0xff, 0x83, 0xff, 0xfe, 0x3f, 0xf8, 0x7f, 0xff, 0x03, 0xff, 0xfe, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0xff, 0xc1, 0xff, 0xfe, 0x1f, 0xf8, 0x7f, 0xfe, 0x07, 0xff, 0xf8, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0xff, 0xe0, 0xff, 0xfe, 0x1f, 0xf8, 0x7f, 0xfe, 0x0f, 0xff, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0xff, 0xf0, 0x7f, 0xff, 0x1f, 0xf8, 0xff, 0xfc, 0x1f, 0xff, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x7f, 0xf8, 0x3f, 0xff, 0x1f, 0xf8, 0xff, 0xf8, 0x3f, 0xff, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x3f, 0xfc, 0x1f, 0xff, 0x1f, 0xf0, 0xff, 0xf0, 0x7f, 0xfc, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0f, 0xfe, 0x0f, 0xff, 0x8f, 0xf0, 0xff, 0xe0, 0xff, 0xf0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x03, 0xff, 0x07, 0xff, 0x8f, 0xf1, 0xff, 0xc1, 0xff, 0xe0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xff, 0x83, 0xff, 0x8f, 0xf1, 0xff, 0x83, 0xff, 0x80, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x7f, 0xe1, 0xff, 0x8f, 0xf1, 0xff, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x7f, 0xcf, 0xe3, 0xfe, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x3f, 0xc7, 0xe3, 0xfc, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x1f, 0xc7, 0xe3, 0xf8, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0xe7, 0xe3, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x07, 0xe7, 0xe7, 0xe1, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x83, 0xe7, 0xc7, 0xc3, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc1, 0xe3, 0xc7, 0x87, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0xf3, 0xc7, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x73, 0xce, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x33, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x13, 0x8c, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0b, 0x88, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

//========================================================================
// Encoder Handlers
//========================================================================

  
// On click, the global selection varuiabel gets updated with
// value of where it was selcted 
void onEb1Clicked(EncoderButton& eb)
{
  // Debugging
  Serial.println("Button pressed!"); 
  //selection = abs(eb.position()); 
  //Serial.println(selection);
}

// A function to handle the 'encoder' event
void onEb1Encoder(EncoderButton& eb) 
{
  // Filter latge spikes
  if(eb.increment() > 4)
  {
    eb.resetPosition(eb.position()); // Reset back to startin pos
  }

  // Reset if encoder goes past active menu limit
  // 
  if (abs(eb.position()) >+ currentScrollLimit)
  {
    eb.resetPosition(0);
  }

  ebState = abs(eb.position());

  // Debugging
  /*
  Serial.print("eb1 position is: ");
  Serial.println(eb.position());
  Serial.print("eb1 State is: ");
  Serial.println(ebState);  
  */
}
 
//========================================================================
// Helper functions
//========================================================================

// Function to print horizontal line of a char
void printHline(char lineChar)
{
  
  for (int i = 0; i < 72; ++i)
  {
    display.print(lineChar);
  }

  display.println();
}

// Function to read user serial input
// Reads int > 0
unsigned short int getSerialInput_int(void)
{
  bool dataAvailable = 0;
  unsigned short int input;

  // Loop until we recieve data
  while(dataAvailable == 0)
  {
    // Read input if data is available
    if (Serial.available() > 0) 
    {
      
      input = Serial.parseInt();
      dataAvailable = 1;

      /*
      // Use this to ignore new line or carrige readings readings
      if (input == 0)
      {
        dataAvailable = 0;
      }
      else
      {
        dataAvailable = 1; // exit loop with selection int
      }   
      */
    }
  }
  return input;  
}

// Function to read user serial input
// Reads single char
char getSerialInput_char(void)
{
  char input = 0;
  bool dataAvailable = 0;

  while (dataAvailable == 0)
  {
    if (Serial.available() > 0) {
         dataAvailable = 1;
        input = Serial.read();      
    }
  }
  return input; 
}

/* Might use later
 // Test for valid input
  for (size_t i = 0; i < sizeof(expectedInputs); ++i)
  {
    // Note: Char can be logiacally compares because it's stored as 8 bit int value
    // Usally matches ASCII code, so char a='a' == char a= 97 
    bool notMatch = (input == expectedInputs[i]);

  }
*/

//========================================================================
// Screen Display functions
//========================================================================

// Bootup fucnction for display
void startInterface(void) 
{ 
  if(!display.begin(SSD1306_SWITCHCAPVCC, screenAddress)) {
    display.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  //Link the event(s) to your function
  eb1.setClickHandler(onEb1Clicked);
  eb1.setEncoderHandler(onEb1Encoder);

  // Display logo for 2 sec
  display.clearDisplay();
  display.drawBitmap(0, 0, logo_bmp, screenWidth, screenHeight - 5, WHITE); // -5, bc getting some weird stuff at bottom of screen
  display.display();
  delay(2000);
  
  display.clearDisplay();  
  display.display();
}

void displayDebug(Menu menu[], size_t menuLength)
{
  char buffer[50]; // init buffer of 50 bytes to hold expected string size
  currentScrollLimit = (menuLength - 1);
  
  // selection = noSelection;
  eb1.update();

  // Setup
  display.clearDisplay();
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
  
  // Printing header line
  display.println("Select module test:");
  for (size_t i = 0; i <= (menuLength - 1); ++i)
  {
    // Highlight line if user is hovering over it
    // Line 0 not clickable 
    if (ebState == i)
    {
      display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
    }
    else 
    {
      display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
    }
    
    // Print out in int and Text format
    sprintf(buffer, "%d. %s", menu[i].choice, menu[i].menuTextPtr);
    display.println(buffer);
  }
  
  display.display();
}

void displayMenu(Menu menu[], size_t menuLength)
{
  char buffer[50]; // init buffer of 50 bytes to hold expected string size
  currentScrollLimit = menuLength;
  
  // selection = noSelection;
  eb1.update();

  // Setup
  display.clearDisplay();
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
  
  // Printing header line
  display.println("Select module test:");
  for (size_t i = 0; i <= (menuLength - 1); ++i)
  {
    // Highlight line if user is hovering over it
    // Line 0 not clickable 
    if (ebState == i)
    {
      display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
    }
    else 
    {
      display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
    }
    
    // Print out in int and Text format
    sprintf(buffer, "%d. %s", menu[i].choice, menu[i].menuTextPtr);
    display.println(buffer);
  }
  
  display.display();
}

// 
void menuUpdate(Menu menu[], size_t menuLength, Menu* menuPtr, size_t* menuLengthPtr)
{
  menuPtr = menu;
  menuLengthPtr = menuLength;
}

/*
//========================================================================
// OG
//========================================================================

// Function to get user menu selection from serial monitor input
// menuName - Name for the desired menu (Main, Sub, Servo, etc.)
// menuOptions - List of options in your testing suite
// menuArraySize - number of elements in menuOptions
unsigned short int menuSelection(String menuName, const char* menuOptions[], size_t menuArraySize)
{
  unsigned short int selection;
  char buffer[50]; // init buffer of 50 bytes to hold expected string size

  printHline('*');
  
  display.println(menuName);

  // Assign item number to menuOption. Starts at 1.
  for (size_t i = 1; i <= menuArraySize; ++i)
  {    
    sprintf(buffer, "%d. %s", i, menuOptions[i-1]);
    display.println(buffer);
  }

  printHline('*');

  display.println("Type item number of desired test: \n"); 
  printHline('*');

  selection = getSerialInput_int();
  
  // Auto catch any invalid menu selection parameters
  // From getSerialInput_int() we assume 0 is not an option
  while (selection > menuArraySize || selection <= 0)
  {
    selection = getSerialInput_int();
  }

  display.display();
  delay(2000);  
  // Return user selection input
  return selection; 
}

// Displays the instructions to a test (pins to connect to, etc.)
// bool return determines if test will proceed or go back to previous screen
bool infoScreen (String infoMsg)
{
  bool proceed = 0;
  unsigned short int selection;
  
  printHline('-');
  display.println("Test Info Screen: ");
  display.println(infoMsg);
  printHline('-');
  
  display.println("1. OK");
  display.println("2. BACK");
  printHline('-');
  display.println("Type item number of desired action:");
  printHline('-');

  selection = getSerialInput_int();
  
  // Loop until we get correct input
  while (selection != 1 && selection != 2)
  {
    display.print(selection); display.print(" is an invalid input! \n");
    display.println("Please try enter 1 or 2");
    selection = getSerialInput_int();
  }

  // Return param to continue to next screen
  if (selection == 1)
  {
    proceed = true;
  }
  // Return param to return to previous screen
  else if (selection == 2)
  {
    proceed = false;
  }

  return proceed;
}

*/


/*
// OG GEMT Main menu
// Highlights option when encoder is postioned on item
// Encouder push selects that item
unsigned int GEMT_mainMenu (void)
{ 
  size_t eb_state = abs(eb1.position());
  selection = noSelection;
  eb1.update();  

  display.clearDisplay();
  display.setTextSize(1); 
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 

  // Print header
  display.println("Select module test:");

  // Prints all lines from menu, may need to add second page if too much text
  for (size_t i = 0; i < mainMenu_length; ++i) 
  {
    // Highlight line if user is hovering over it
    // Line 0 not clickable 
    if (eb_state == (i+1))
    {
      display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
    }
    else 
    {
      display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
    }

    display.println(main_menu[i].menuTextPtr);  
  }

  // Return to top of list if encoder pos goes past last choice
  // In future could update to transition to a second page
  if (eb_state > (mainMenu_length - 1))
  {
    eb1.resetPosition(1); 
  }
 
  display.display();

  return selection; // return default if nothing selection, otherwise returns value of selction
}
*/

#endif 