#ifndef gemt_interface_h
#define gemt_interface_h


#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Fonts/Org_01.h>
#include <Adafruit_SSD1306.h>
#include <EncoderButton.h>
#include "Arduino.h"


//========================================================================
// Pin Definitions
//========================================================================

enum encoderSWPins 
{
  pinA = 8,
  pinB = 9,
  pinSW = 10
};

enum oledDisplayPins
{
  screenWidth = 128,
  screenHeight = 64,
  screenAddress = 0x3C, // i2c Address
  screenReset = -1 // -1 since sharing Arduino reset pin
};

//========================================================================
// Menu Definitions
//========================================================================

// Init array of pointers for menus
  const char* mainMenu[] = 
  {
    "Setup (run once)",
    "9G Servo Test",
    "ESR Test",
    "nRF24 Test",
    "L298N Test",
    "Ultrasonic Sensor Test"
  };

  // Submenu for servo
  // Note: Submenus should have back to return to previos menu
  // TODO: Find better way of incorporating menu heirchy
  const char* servoMenu[] = 
  {
    "Manual Operation Test",
    "Automatic Operation Test",
    "Back"
  };

//========================================================================
// Initializers
//========================================================================

// Display init
Adafruit_SSD1306 display(screenWidth, screenHeight, &Wire, screenReset);

// EncoderSW init
EncoderButton eb1(pinA, pinB, pinSW);

// Logo Bitmap Init
 const uint8_t  logo_bmp [] PROGMEM = 
{ 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0x86, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x80, 0x00, 0x3e, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x77, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x38, 0x01, 0xc3, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x0e, 0x07, 0x81, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x87, 0x03, 0x8e, 0x00, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0xf8, 0x00, 0x70, 0x00, 0x00, 
  0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x30, 0x00, 0x38, 0x00, 0x00, 
  0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 
  0x00, 0x00, 0xe0, 0x00, 0x3f, 0xfc, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
  0x00, 0x01, 0xc0, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 
  0x00, 0x03, 0x80, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 
  0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 
  0x00, 0x0e, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 
  0x00, 0x1c, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 
  0x00, 0x38, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
  0x00, 0x78, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0x87, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x01, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xf8, 0x7f, 0xfc, 0x1f, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xc0, 
  0x00, 0x7f, 0xff, 0xe0, 0x7f, 0xff, 0xfc, 0x7f, 0xfc, 0x3f, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0x00, 
  0x00, 0x1f, 0xff, 0xf0, 0x3f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xf0, 0x3f, 0xff, 0xfc, 0x00, 
  0x00, 0x07, 0xff, 0xfc, 0x1f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xe0, 0x7f, 0xff, 0xf0, 0x00, 
  0x00, 0x03, 0xff, 0xfe, 0x0f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xc0, 0xff, 0xff, 0xc0, 0x00, 
  0x00, 0x00, 0xff, 0xff, 0x07, 0xff, 0xfe, 0x3f, 0xfc, 0x7f, 0xff, 0x81, 0xff, 0xff, 0x80, 0x00, 
  0x00, 0x00, 0x3f, 0xff, 0x83, 0xff, 0xfe, 0x3f, 0xf8, 0x7f, 0xff, 0x03, 0xff, 0xfe, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0xff, 0xc1, 0xff, 0xfe, 0x1f, 0xf8, 0x7f, 0xfe, 0x07, 0xff, 0xf8, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0xff, 0xe0, 0xff, 0xfe, 0x1f, 0xf8, 0x7f, 0xfe, 0x0f, 0xff, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0xff, 0xf0, 0x7f, 0xff, 0x1f, 0xf8, 0xff, 0xfc, 0x1f, 0xff, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x7f, 0xf8, 0x3f, 0xff, 0x1f, 0xf8, 0xff, 0xf8, 0x3f, 0xff, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x3f, 0xfc, 0x1f, 0xff, 0x1f, 0xf0, 0xff, 0xf0, 0x7f, 0xfc, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0f, 0xfe, 0x0f, 0xff, 0x8f, 0xf0, 0xff, 0xe0, 0xff, 0xf0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x03, 0xff, 0x07, 0xff, 0x8f, 0xf1, 0xff, 0xc1, 0xff, 0xe0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xff, 0x83, 0xff, 0x8f, 0xf1, 0xff, 0x83, 0xff, 0x80, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x7f, 0xe1, 0xff, 0x8f, 0xf1, 0xff, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x7f, 0xcf, 0xe3, 0xfe, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x3f, 0xc7, 0xe3, 0xfc, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x1f, 0xc7, 0xe3, 0xf8, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0xe7, 0xe3, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x07, 0xe7, 0xe7, 0xe1, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x83, 0xe7, 0xc7, 0xc3, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc1, 0xe3, 0xc7, 0x87, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0xf3, 0xc7, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x73, 0xce, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x33, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x13, 0x8c, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0b, 0x88, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

// Selection cases
enum {noSelection = 100}; // Default value
unsigned int selection;

typedef void (*Menu_Processing_Function_Pointer)(void);
struct Menu_Option
  {
    unsigned int choice;
    const char * menuTextPtr;
    //Menu_Processing_Function_Pointer p_processing_function;
  };

//========================================================================
// Encoder Handlers
//========================================================================

// On click, the global selection varuiabel gets updated with
// value of where it was selcted 
void onEb1Clicked(EncoderButton& eb) 
{
  // Debugging
  Serial.println("Button pressed!"); 
  selection = abs(eb.position()); 
  Serial.println(selection);
}

// A function to handle the 'encoder' event
void onEb1Encoder(EncoderButton& eb) 
{
  // compensate for random spikes
  unsigned int encoder_state = abs(eb.position());
  if(eb.increment() > 5)
  {
    eb.resetPosition(eb.position() + 1);
  }

  // Debugging
  Serial.print("eb1 incremented by: ");
  Serial.println(eb.increment());
  Serial.print("eb1 position is: ");
  Serial.println(eb.position());
}

//========================================================================
// OLED Functions
//========================================================================

// Bootup fucnction for display
void GEMT_displayInit(void) 
{ 
  if(!display.begin(SSD1306_SWITCHCAPVCC, screenAddress)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }
    
  //Link the event(s) to your function
  eb1.setClickHandler(onEb1Clicked);
  eb1.setEncoderHandler(onEb1Encoder);

  
  // Display logo for 2 sec
  display.clearDisplay();
  display.drawBitmap(0, 0, logo_bmp, screenWidth, screenHeight - 5, WHITE); // -5, bc getting some weird stuff at bottom of screen
  display.display();
  delay(5000);
  
  display.clearDisplay();  
  display.display();
}

static const Menu_Option main_menu[] =
{
  {0, "Motor Driver"},
  {1, "UltraSonic Sensor"},
  {2, "Capacitor"},
  {3, "9G Micro Servo"},
  {4, "nRF24L01"},
};

static const size_t mainMenu_length =
        sizeof(main_menu) / sizeof(main_menu[0]);


unsigned int GEMT_mainMenu (void)
{ 
  size_t eb_state = abs(eb1.position());
  selection = noSelection;
  eb1.update();  

  display.clearDisplay();
  display.setTextSize(1); 
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 

  // Print header
  display.println("Select module test:");

  // Prints all lines from menu, may need to add second page if too much text
  for (size_t i = 0; i < mainMenu_length; ++i) 
  {
    // Highlight line if user is hovering over it
    // Line 0 not clickable 
    if (eb_state == (i+1))
    {
      display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
    }
    else 
    {
      display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
    }

    display.println(main_menu[i].menuTextPtr);
  
  }

  // Return to top of list if encoder pos goes past last choice
  // In future could update to transition to a second page
  if (eb_state > (mainMenu_length - 1))
  {
    eb1.resetPosition(1); 
  }
 
  display.display();

  return selection; // return default if nothing selection, otherwise returns value of selction
}



//========================================================================
// Helper functions
//========================================================================

// Function to print horizontal line of a char
void printHline(char lineChar)
{
  
  for (int i = 0; i < 72; ++i)
  {
    Serial.print(lineChar);
  }

  Serial.println();
}


// Function to read user serial input
// Reads int > 0
unsigned short int getSerialInput_int(void)
{
  bool dataAvailable = 0;
  unsigned short int input;

  // Loop until we recieve data
  while(dataAvailable == 0)
  {
    // Read input if data is available
    if (Serial.available() > 0) 
    {
      
      input = Serial.parseInt();
      dataAvailable = 1;

      /*
      // Use this to ignore new line or carrige readings readings
      if (input == 0)
      {
        dataAvailable = 0;
      }
      else
      {
        dataAvailable = 1; // exit loop with selection int
      }   
      */
    }
  }
  return input;  
}

// Function to read user serial input
// Reads single char
char getSerialInput_char(void)
{
  char input = 0;
  bool dataAvailable = 0;

  while (dataAvailable == 0)
  {
    if (Serial.available() > 0) {
         dataAvailable = 1;
        input = Serial.read();      
    }
  }
  return input; 
}

/* Might use later
 // Test for valid input
  for (size_t i = 0; i < sizeof(expectedInputs); ++i)
  {
    // Note: Char can be logiacally compares because it's stored as 8 bit int value
    // Usally matches ASCII code, so char a='a' == char a= 97 
    bool notMatch = (input == expectedInputs[i]);

  }
*/



//========================================================================
// Screen Display functions
//========================================================================

// Function to get user menu selection from serial monitor input
// menuName - Name for the desired menu (Main, Sub, Servo, etc.)
// menuOptions - List of options in your testing suite
// menuArraySize - number of elements in menuOptions
unsigned short int menuSelection(String menuName, const char* menuOptions[], size_t menuArraySize)
{
  unsigned short int selection;
  char buffer[50]; // init buffer of 50 bytes to hold expected string size

  printHline('*');
  
  Serial.println(menuName);

  // Assign item number to menuOption. Starts at 1.
  for (size_t i = 1; i <= menuArraySize; ++i)
  {    
    sprintf(buffer, "%d. %s", i, menuOptions[i-1]);
    Serial.println(buffer);
  }

  printHline('*');

  Serial.println("Type item number of desired test: \n"); 
  printHline('*');

  selection = getSerialInput_int();
  
  // Auto catch any invalid menu selection parameters
  // From getSerialInput_int() we assume 0 is not an option
  while (selection > menuArraySize || selection <= 0)
  {
    selection = getSerialInput_int();
  }
    
  // Return user selection input
  return selection; 
}


// Displays the instructions to a test (pins to connect to, etc.)
// bool return determines if test will proceed or go back to previous screen
bool infoScreen (String infoMsg)
{
  bool proceed = 0;
  unsigned short int selection;
  
  printHline('-');
  Serial.println("Test Info Screen: ");
  Serial.println(infoMsg);
  printHline('-');
  
  Serial.println("1. OK");
  Serial.println("2. BACK");
  printHline('-');
  Serial.println("Type item number of desired action:");
  printHline('-');

  selection = getSerialInput_int();
  
  // Loop until we get correct input
  while (selection != 1 && selection != 2)
  {
    Serial.print(selection); Serial.print(" is an invalid input! \n");
    Serial.println("Please try enter 1 or 2");
    selection = getSerialInput_int();
  }

  // Return param to continue to next screen
  if (selection == 1)
  {
    proceed = true;
  }
  // Return param to return to previous screen
  else if (selection == 2)
  {
    proceed = false;
  }

  return proceed;
}





#endif 