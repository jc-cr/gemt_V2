#include "HardwareSerial.h"
#ifndef gemt_interface_h
#define gemt_interface_h

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Fonts/Org_01.h>
#include <Adafruit_SSD1306.h>
#include <EncoderButton.h>
#include "Arduino.h"
/*========================================================================
 TODO:
  - Integrate hardware tests
  -  ...
========================================================================*/

//========================================================================
// Global Definitions
//========================================================================

#define displayRowLimit 8;
#define displayColLimit 21;

unsigned short int ebState = 0; // Current state (Position) of the encoder 
unsigned short int currentScrollLimit = 0; // Updated within displayMenu function
static bool clicked = false; // Updated on encoder "click" case, must reset after use 

enum encoderSWPins 
{
  pinA = 19 , // CLK
  pinB = 2, // DT
  pinSW = 8 // SW
};

enum oledDisplayPins
{
  screenWidth = 128,
  screenHeight = 64,
  screenAddress = 0x3C, // i2c Address
  screenReset = -1      // -1 since sharing Arduino reset pin
};

//========================================================================
// Initializers
//========================================================================

// Display init
Adafruit_SSD1306 display(screenWidth, screenHeight, &Wire, screenReset);

// EncoderSW init
EncoderButton eb1(pinA, pinB, pinSW);

// Logo Bitmap Init
 const uint8_t  logo_bmp [] PROGMEM = 
{ 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0x86, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x80, 0x00, 0x3e, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x77, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x38, 0x01, 0xc3, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x0e, 0x07, 0x81, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x87, 0x03, 0x8e, 0x00, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0xf8, 0x00, 0x70, 0x00, 0x00, 
  0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x30, 0x00, 0x38, 0x00, 0x00, 
  0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 
  0x00, 0x00, 0xe0, 0x00, 0x3f, 0xfc, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
  0x00, 0x01, 0xc0, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 
  0x00, 0x03, 0x80, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 
  0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 
  0x00, 0x0e, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 
  0x00, 0x1c, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 
  0x00, 0x38, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
  0x00, 0x78, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0x87, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x01, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xf8, 0x7f, 0xfc, 0x1f, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xc0, 
  0x00, 0x7f, 0xff, 0xe0, 0x7f, 0xff, 0xfc, 0x7f, 0xfc, 0x3f, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0x00, 
  0x00, 0x1f, 0xff, 0xf0, 0x3f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xf0, 0x3f, 0xff, 0xfc, 0x00, 
  0x00, 0x07, 0xff, 0xfc, 0x1f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xe0, 0x7f, 0xff, 0xf0, 0x00, 
  0x00, 0x03, 0xff, 0xfe, 0x0f, 0xff, 0xfc, 0x3f, 0xfc, 0x3f, 0xff, 0xc0, 0xff, 0xff, 0xc0, 0x00, 
  0x00, 0x00, 0xff, 0xff, 0x07, 0xff, 0xfe, 0x3f, 0xfc, 0x7f, 0xff, 0x81, 0xff, 0xff, 0x80, 0x00, 
  0x00, 0x00, 0x3f, 0xff, 0x83, 0xff, 0xfe, 0x3f, 0xf8, 0x7f, 0xff, 0x03, 0xff, 0xfe, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0xff, 0xc1, 0xff, 0xfe, 0x1f, 0xf8, 0x7f, 0xfe, 0x07, 0xff, 0xf8, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0xff, 0xe0, 0xff, 0xfe, 0x1f, 0xf8, 0x7f, 0xfe, 0x0f, 0xff, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0xff, 0xf0, 0x7f, 0xff, 0x1f, 0xf8, 0xff, 0xfc, 0x1f, 0xff, 0xc0, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x7f, 0xf8, 0x3f, 0xff, 0x1f, 0xf8, 0xff, 0xf8, 0x3f, 0xff, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x3f, 0xfc, 0x1f, 0xff, 0x1f, 0xf0, 0xff, 0xf0, 0x7f, 0xfc, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0f, 0xfe, 0x0f, 0xff, 0x8f, 0xf0, 0xff, 0xe0, 0xff, 0xf0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x03, 0xff, 0x07, 0xff, 0x8f, 0xf1, 0xff, 0xc1, 0xff, 0xe0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xff, 0x83, 0xff, 0x8f, 0xf1, 0xff, 0x83, 0xff, 0x80, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x7f, 0xe1, 0xff, 0x8f, 0xf1, 0xff, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x7f, 0xcf, 0xe3, 0xfe, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x3f, 0xc7, 0xe3, 0xfc, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x1f, 0xc7, 0xe3, 0xf8, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0xe7, 0xe3, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x07, 0xe7, 0xe7, 0xe1, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x83, 0xe7, 0xc7, 0xc3, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc1, 0xe3, 0xc7, 0x87, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0xf3, 0xc7, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x73, 0xce, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x33, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x13, 0x8c, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0b, 0x88, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

//========================================================================
// Encoder Handlers
//========================================================================
  
// On click, the global selection variable gets updated with
// value of where it was selcted
void onEb1Clicked(EncoderButton& eb)
{
  // Set selection value to current state
  clicked = true;
  
  // DEBUG - Delete in actual proram as Serial printing slows down interrupts
  //Serial.println("CLICKED!");
}

// A function to handle the 'encoder' event
void onEb1Encoder(EncoderButton& eb) 
{
  // Filter latge spikes from noise
  if(eb.increment() > 4)
  {
    eb.resetPosition(eb.position()); // Reset back to startin pos
  }

  // Reset if encoder goes past active Menu limit
  if (abs(eb.position()) >= currentScrollLimit)
  {
    eb.resetPosition(0);
  }

  ebState = abs(eb.position());
  //Serial.println(ebState);
}
 
//========================================================================
// Helper functions
//========================================================================

// Function to print horizontal line of a char
void printHline(char lineChar)
{
  for (int i = 0; i < 72; ++i)
  {
    Serial.print(lineChar);
  }

  Serial.println();
}

// Function to quicly call actions required to prep screen for printing
void displayPrep(void)
{
    display.clearDisplay();
    display.setCursor(0, 0);
    display.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
}

// Create function for clarity
void resetClicked(void)
{
  clicked = 0;
}

//========================================================================
// Menu Functions (WIP)
//========================================================================

/* A linked list node:

   Normally we would have to free since we use malloc()
   But here we addign all the memory allocation before the program 
   starts, so any memory errors would be caught from the onset.

  Also our allocation are static, not dynamic, after they have been set.
  When power is removed from our microcontorller, the memory will be freed.
  https://stackoverflow.com/questions/57477689/what-happens-if-you-dont-free-allocated-memory-in-a-microcontroller
*/
// https://www.geeksforgeeks.org/generic-linked-list-in-c-2/
typedef struct Node
{
    // Any data type can be stored in this node
    void  *data;

    // Pointer to next node, Null if at end of linked list
    struct Node *next;
} Node;

// Append to the end of linked list
static void appendArgs(Node* head, void *new_data)
{ 
  // First let's traverse the linked list and go to the end...

  // Setup a Node pointer to iterate with
  Node *current = head;

  // Go to end of current list, 
  // this works beacause last pointer of list will be NULL
  while (current->next != NULL) {
      current = current->next;
  }

  // Now setup a new node...

  // Setup memory for new node
  current->next = (Node*) malloc(sizeof(Node));

  // Copy contents of new_data to newly allocated memory by 1 byte (uint8_t)
  for (int i=0; i<sizeof(new_data); i++)
  {
      *(uint8_t *)(current->next->data + i) = *(uint8_t *)(new_data + i);
  }
  
  current->next->next = NULL;
}

// Menu screen template
typedef struct Menu
{
  unsigned short int choice;
  const char* menuTextPtr;
  void (*selectionAction)(...); // Function pointer to Menu selection action
  unsigned short int numberOfArgsForAction;
  Node *firstArg; // Starts with Null
  // Method styling in C https://www.cs.uaf.edu/courses/cs301/2014-fall/notes/methods/index.html
  // Ellipses ref https://www.lemoda.net/c/function-pointer-ellipsis/
} Menu;


// Function to store arguments in a linked list within given struct
// Ref: variable args in C https://ssjools.hopto.org/char/lang/valist
void setActionArgs(Menu Menu[], ...)
{
  unsigned short int numOfArgs = Menu->numberOfArgsForAction;
  va_list vargs;
  va_start(vargs, Menu);

  for (int i = 0; i < numOfArgs; i++)
  {
    appendArgs(Menu->firstArg, vargs);
  }

  va_end(vargs);
}

// Needed some way to pass all params for generic functions so we define generic vars
// https://stackoverflow.com/questions/7798383/array-of-pointers-to-multiple-types-c
void **args = malloc(4 * sizeof(void *)); // 4 for debugging... think max will be set to 5

// Extract a menu items arguments and store in above args array
static void extractArgs(Menu Menu[])
{
  unsigned short int numOfArgs = Menu->numberOfArgsForAction;
  
  // Setup a Node pointer to iterate with
  Node *current = Menu->firstArg;
  
  for (int i = 0; i < numOfArgs; i++)
  {
    args[i] = current->data;
    current = current->next;
  }
}
    
void invokeSelection(Menu Menu[])
{ 
  unsigned short int numOfArgs = Menu->numberOfArgsForAction;
  extractArgs(Menu);

  switch(numOfArgs)
  {
    case 4:
    {
      Menu->selectionAction(args[0], args[1], args[2], args[3]);
    }
    default:
    {
      Serial.println("ERROR: No argument number defined.");
      return;
    }
  }
}

//========================================================================
// Screen Display Functions
//========================================================================

// Bootup fucnction for display
void startInterface(void) 
{ 
  if(!display.begin(SSD1306_SWITCHCAPVCC, screenAddress)) {
    display.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  //Link the event(s) to your function
  eb1.setClickHandler(onEb1Clicked);
  eb1.setEncoderHandler(onEb1Encoder);

  // Display logo for 2 sec
  display.clearDisplay();
  display.drawBitmap(0, 0, logo_bmp, screenWidth, screenHeight - 5, WHITE); // -5, bc getting some weird stuff at bottom of screen
  display.display();
  delay(2000);
  
  display.clearDisplay();  
  display.display();
}

// 
void displayMenu(Menu CurrentMenu[], size_t menuLength)
{
  // Condition for executing users selections based on 'clicked' bool
  if (clicked)
  {
    resetClicked(); // Reset before proceeding to function
    invokeSelection(&CurrentMenu[ebState]);
  }

  //Display the previous Menu state
  else
  {
    char buffer[50]; // init buffer of 50 bytes to hold expected string size
    currentScrollLimit = menuLength;

    // Setup
    eb1.update();
    displayPrep();
    
    // Printing header line
    display.println("Select module test:");
    // Display all current Menu options
    for (size_t i = 0; i <= (menuLength - 1); ++i)
    {
      // Highlight line if user is hovering over it
      if (ebState == i)
      {
        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
      }
      else 
      {
        display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
      }
      
      // Print out in int and Text format
      sprintf(buffer, "%d. %s", CurrentMenu[i].choice, CurrentMenu[i].menuTextPtr);
      display.println(buffer);
    }
    
    display.display();
  }
}

//========================================================================
// Selection Action Functions
//========================================================================

// Changes Menu pointer to point to selected Menu screen
void menuUpdate(Menu NewMenu[], size_t newMenuLength, Menu* OldMenuPtr, size_t* oldMenuLengthPtr)
{

  OldMenuPtr = NewMenu;
  oldMenuLengthPtr = newMenuLength;
}

//========================================================================
// Debugging
//========================================================================

static const char *confirmOptions[3] = {"OK", "|", "Back"};
static const size_t confirmOptionLen = sizeof(confirmOptions) / sizeof(confirmOptions[0]);

// Reusable function for printing the confirmOptions above
void printConfirmOptions(void)
{
  for (size_t i = 0; i < confirmOptionLen; i++)
  {
     // Highlight line if user is hovering over it
     // Don't highlight the bar though
      if (ebState == i && i != 1)
      {
        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
      }
      else 
      {
        display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
      }
       
       display.print(confirmOptions[i]);
  }
}

void dummyInfo(void)
{
  currentScrollLimit = 3;
  eb1.update();

  displayPrep();
  display.println("Test Information:");
  display.println();
  display.println("This is a demo of an info screen"); display.println("for a test.");
  display.println();

  printConfirmOptions();

  display.display();
}

// Demo of test screen functionality
void dummyTest(void)
{
  while(clicked == 0)
  { 
    dummyInfo();
    delay(3);
  }
  resetClicked();

  while(clicked == 0)
  {
    eb1.update();

    displayPrep();
    display.println("This is a screen for the actual test");
    display.println();

    printConfirmOptions();

    display.display();
    delay(3);
  }
  resetClicked();
}

// Demo of a submenu functionality
// For implementation would prefer to pass a pointer in main
void dummyMenu(void)
{
  // Make a Dumb Menu
  static Menu DumbMenu[] =
  {
    {1, "Test 1", dummyTest},
    {2,  "Test 2", dummyTest},
    {3, "Dumb Menu", dummyMenu}, // Action - Update Menu, Main
  };
  size_t dumbMenuLength = sizeof(DumbMenu) / sizeof(DumbMenu[0]);

  while(true)
  {
    displayMenu(DumbMenu, dumbMenuLength);

    // Make sure clicked status is passed on
    if (clicked)
    {
      displayMenu(DumbMenu, dumbMenuLength);
      break;
    }
    delay(3);
  }
  resetClicked();
}

#endif 